import socket
import os
import logging
import dicts
import datetime
# from Modules.post import *

logger = logging.getLogger(__name__)

class Handle_GET():
    'A class module for responding to get requests'


    def __init__(self):
        pass

    def handle_GET(self, uri, connection) :
        '''Precondition : Takes in a string that contains a GET request. 
            Takes in the socket object, so that it can close if needed.
        Postcondition: Returns a None if sucessful.
        Description  : Sends an html file. If none is found prepares an error message and sends it.'''

        try:
            print("s1")
            filename = uri.strip("/")
            html_asset = filename.split("?")
            html_asset = html_asset[0]
            response_body = ""
            print("s2")
            if os.path.exists(html_asset) :
                print("s3")
                final_response = self.response_line( dicts.status_codes[200]).encode()
                print("s4")
                with open(html_asset, 'rb') as f:
                    print("s5")
                    resp = f.read()
                    f.close()
                    final_response += "Content-type: ".encode()
                response_body = resp

            else :
                final_response = self.response_line( dicts.status_codes[404]).encode()
                response_body = "<h1>404 Not Found</h1>".encode()

        except Exception as e6:
            #If an error occurs, it will send an error message to the requesting client
            logger.error(f'Failed to find resource or format 404 error message: {e6}')
            final_response = self.response_line( dicts.status_codes[500]).encode()
            response_body = "<h1>500 Internal Error</h1>".encode()
            final_R = final_response + "\r\n".encode() + response_body

                #This is bad coding practice, it should be redone
                #to not use an exception to set a default mime type
        try:
            mime = "." + filename.split(".")[-1]
            final_response += dicts.mime_types[mime].encode()
        except:
            final_response = self.response_line( dicts.status_codes[200]).encode()
            final_response += dicts.mime_types['.html'].encode()


        final_response += datetime.datetime.strftime(datetime.datetime.utcnow(), '\nDate: %a, %d %b %Y %H:%M:%S GMT \n').encode()
        final_response += "Content-Length: ".encode() + str(len(response_body)).encode() + "\n".encode()
        final_R = final_response + "\r\n".encode() + response_body

        try:
            final_R #final_R.encode()????
        except Exception as e7:
            logger.error(f'Failed to encode header & resources to send: {e7}')
            #If encode fails close socket, break loop, close thread??
            connection.close()
            return(1)

        try:
            connection.send(final_R) #final_R.encode()????
            connection.close()
        except Exception as e8:
            logger.error(f'Sending resource failed: {e8}')
            connection.close()
            return(1)

    def response_line(self, status_code) :
        '''    Precondition : Takes in an int of the status code message.
    Postcondition: Creates the HTTP Header string for the response.
    Description  : Creates the HTTP Header string for the response.'''

        for num, code in dicts.status_codes.items():
            if code == status_code:
                msg = num

        response = "HTTP/1.0 %s %s\r\n" % (msg, status_code)

        return response