import socket
import os
import logging
import dicts

logger = logging.getLogger(__name__)

class Handle_GET():
    'A class module for responding to get requests'

    def __init__(self):
        pass

# Precondition : Takes in a string that contains a GET request. 
#                Takes in the socket object, so that it can close if needed.
# Postcondition: Returns a None if sucessful.
# Description  : Sends an html file. If none is found prepares an error message and sends it.

    def handle_GET(self, uri, connection) :

        try:
            filename = uri.strip("/")
            print(filename)

            pieces = filename.split("/")
            response_body = ""

            if os.path.exists(filename) :
                final_response = self.response_line(self, dicts.status_codes[200]).encode()

                with open(filename, 'rb') as f:
                    resp = f.read()
                    f.close()
                    final_response += "Content-type: ".encode()
                    #This is bad coding practice, it should be redone
                    #to not use an exception to set a default mime type
                    try:
                        mime = "." + filename.split(".")[-1]
                        final_response += dicts.mime_types[mime].encode()
                    except:
                        final_response = self.response_line(self, dicts.status_codes[200]).encode()
                        final_response += dicts.mime_types['.html'].encode()
                    response_body = resp
            else :
                final_response = self.response_line(self, dicts.status_codes[404]).encode()
                response_body = "<h1>404 Not Found</h1>".encode()

            final_R = final_response + "\r\n".encode() + response_body

        except Exception as e6:
            #If an error occurs, it will send an error message to the requesting client
            logger.error(f'Failed to find resource or format 404 error message: {e6}')
            final_response = self.response_line(self, dicts.status_codes[500]).encode()
            response_body = "<h1>500 Internal Error</h1>".encode()
            final_R = final_response + "\r\n".encode() + response_body

        try:
            final_R
        except Exception as e7:
            logger.error(f'Failed to encode header & resources to send: {e7}')
            #If encode fails close socket, break loop, close thread??
            connection.close()
            return(1)

        try:
            connection.send(final_R)
        except Exception as e8:
            logger.error(f'Sending resource failed: {e8}')
            connection.close()
            return(1)

    # Precondition : Takes in an int of the status code message.
    # Postcondition: Creates the HTTP Header string for the response.
    # Description  : Creates the HTTP Header string for the response.
    def response_line(self, status_code) :
        for num, code in dicts.status_codes.items():
            if code == status_code:
                msg = num

        response = "HTTP/1.0 %s %s\r\n" % (msg, status_code)

        return response
