import socket
from _thread import *
import threading
import os
import sys
import atexit
import logging

# import test_main    #for testing purposes

class sckt_class():
    '''precondition: Accepts host and port from Main Class, creates a socket, and accepts connection
postcondition: Provides getters and setters as well as returns a socket
description: This class gives us methods to utilize to create connections.'''

    #----------Logging configuration----------
    # Custom logger creation
    global logger
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    # Formatter -> time -- the module where execution starts -- log level -- message
    formatter = logging.Formatter('%(asctime)s -- %(name)s -- %(levelname)s -- %(funcName)s -- %(lineno)d: %(message)s')

    # File log configuration
    f_handler = logging.FileHandler('file.log')
    f_handler.setLevel(logging.DEBUG)
    f_handler.setFormatter(formatter)
    logger.addHandler(f_handler)

    # Console log configuration
    c_handler = logging.StreamHandler()
    c_handler.setLevel(logging.DEBUG)
    c_handler.setFormatter(formatter)
    logger.addHandler(c_handler)

    # Test/example logs
    logger.debug('Logger started from ' + __name__)

    #-----------------------------------------

    #private/protected host and port variables
    _host = ''
    _port = 8080
    _ASSET_DIRECTORY = 'ASSETS'
    __VERSION = '1'

    def __init__(self, host, port):
        self.host = host
        self.port = port

    @property
    def host(self):
        logging.info('Getting host')
        return self._host

    @host.setter
    def host(self, h):
        logging.info('Setting host')
        self._host = h

    @property
    def prt(self):
        logging.info('Getting port')
        return self._port

    @prt.setter
    def prt(self, p):
        logging.info('Setting port')
        self._port = int(p)



    def set_cwd(self, new_dir):
        ''' Precondition : Take in a string of directory to change to.
            Postcondition: The current execution enviornment will be moved to that directory and restrict it to and all sub-folders.
                Returns the full pathname on sucess. On failure does not change and returns current working directory.
            Description  : Change the current working directory'''

        try:
            __cwd = './' + self._ASSET_DIRECTORY
            #print('Changing the current working directory to %s\n', __cwd)
            logging.warning(f'Changing the current working directory to {__cwd}')
            os.chdir(__cwd)
            return __cwd
        except Exception as e1:
            logging.error(f'Setting the working directory failed. CWD remains the same: {e1}')
            __cwd = os.getcwd()
            return __cwd


    def cmds(self):
        '''  Precondition : Should only be called from a child process.
             Postcondition: returns a 0 on sucess, or a 1 on error
             Description  : Provides a basic interface to control each server instance.'''


        # If a string is provided use it
        # cli = cmd_input;
        # Else accept input from the shell
        print("\n Server can be shutdown with 'exit' \n")
        while True:
            __cli = input()
            if __cli == 'Exit' or __cli =='exit' or __cli =='exit()' or __cli =='stop' or __cli =='Stop' or __cli =='end' or __cli =='End' or __cli =='Quit' or __cli =='quit' or __cli=='close' or __cli=='Close' or __cli=='abort' or __cli == 'Abort':
                logging.info('\n Shutting down server')
                logging.warning("User has initiated server shutdown")
                try:
                    os._exit(0)
                    break
                except Exception as e2:
                    logging.error(f'Error in shutdown: {e2}')
                    return(1)
        return 0


    def sckt(self):
        '''  Precondition : Computer needs an active network connection.
             Postcondition: Creates socket that is listening.
             Description  : Creates a socket that can be used to accept or send network data. '''


        #Need to look into exception handling for threads.
        '''https://stackoverflow.com/questions/2829329/catch-a-threads-exception-in-the-caller-thread-in-python'''
        cmd_thread = threading.Thread(target=self.cmds, args = ())
        cmd_thread.start()
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            ###############
            s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
            s.bind((self._host, self._port))
            logging.info(f'Socket binded to port {self._port}')
            #print("socket binded to port ", self._port)
            s.listen(128) #If the value is less than 128 in linux it will be silently truncated to the lower value.
            logging.info('Socket listening ...')
            return s
        except Exception as e3:
            logging.error(f'Failed to create socket: {e3}')
            os._exit(1)


    def acpt(self, c):
        '''  Precondition : Needs a socket object.
             Postcondition: Accepts and decodes incoming data. Returns that data as a string and the socket_connection object
             Description  : Accept incoming network data.'''
        try:
            c_socket, c_address = c.accept()
            logging.info(f'addr{c_address}')
        except Exception as e4_a:
            logging.error(f'Failed to accept socket: {e4_a}')
            self.connection.close()
            return 1
        try:
            data = c_socket.recv(1024).decode('utf-8')
            return data, c_socket
            
        except Exception as e4_b:
            logging.error(f'Failed to recieve and decode socket: {e4_b}')
            self.connection.close()
            return 1



    def modules_to_thread(self):
        '''  Precondition : Method for inherited classes. Takes in any objects needed. 
             Postcondition: Runs methods in order and passes any parameters from one to the next as needed.
             Description  : Proto-type code. This method is used for threading. Anything with in this method will be threaded when a server is created.'''
        pass


    def thread_server(self):
        '''     Precondition :
         Postcondition:
         Description  : Proto-type code for threading a socket/server'''
        
        s = sckt()

        while True:
            t1 = threading.Thread(target=self.modules_to_thread, args=(s,),daemon=True)
            t1.start()
            t1.join()


    def create_processes(self):
        ''' Precondition :
            Postcondition:
            Description  : proto-type code if processes will be used.'''

        process_count = 0
        MAX_PROCESS = 50
        s = sckt()

        while True:
            if (process_count < MAX_PROCESS):
                p1 = multiprocessing.Process(target=self.modules_to_thread, args=(s,))
                process_count = process_count + 1
                p1.start()
                #Need a way to decrement the process count.


# if __name__ == '__main__':                  #for testing purposes
#     temp = sckt_class('127.0.0.1', 8080)
#     print(temp)
#     ahost = sckt_class('127.0.0.1', 8080)
#     ahost.set_host = '123.0.0.1'
#     print(ahost.get_host)



####################################
#   FOR TESTING PURPOSES    #
# def Socket_Class():       
#     host = ""          #will be taken from the main class
#     port = 8080        #will be taken from the main class

#     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#     s.bind((host, port))
#     print("socket binded to port ", port)
#     s.listen()          #number of connections allowed can be specified after
#     print("socket listening ...")
#     # while True:
#     #c, addr = s.accept()         #will be implemented in HTTP class
#     #print("connected to ", addr)
#         # data = c.recv(1024)
#         # if not data:
#         #     print("Bye")
#         #     break

#     s.close()             #won't need it, we want it to remain open

# if __name__ == '__main__':
#     Socket_Class()
######################################