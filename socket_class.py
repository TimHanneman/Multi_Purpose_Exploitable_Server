#socket class
#precondition: Accepts host and port from Main Class, creates a socket, and accepts connection
#postcondition: Provides getters and setters as well as returns a socket
#description: This class gives us methods to utilize to create connections.

import socket
from _thread import *
import threading
import os
import sys
import atexit
import logging

# import test_main    #for testing purposes

class sckt_class():

    #Logging configuration
    # Custom logger creation
    global logger
    logger = logging.getLogger()

    # Handler creation
    f_handler = logging.FileHandler('file.log')
    c_handler = logging.StreamHandler()
    f_handler.setLevel(logging.WARNING)
    c_handler.setLevel(logging.DEBUG)

    # Formatter creation -> time -- the module where execution starts -- log level -- message
    f_format = logging.Formatter('%(asctime)s -- %(name)s -- %(levelname)s -- %(message)s')
    c_format = logging.Formatter('%(asctime)s -- %(name)s -- %(levelname)s -- %(message)s')
    f_handler.setFormatter(f_format)
    c_handler.setFormatter(c_format)

    # Add handlers to the logger
    logger.addHandler(f_handler)
    logger.addHandler(c_handler)

    # Test/example logs
    logger.warning('logger started')

    #-----------------------------------------

    #private/protected host and port variables
    _host = ''
    _port = 8080
    _ASSET_DIRECTORY = 'ASSETS'
    __VERSION = '1'

    def __init__(self, host, port):
        self.host = host
        self.port = port

    @property
    def host(self):
        print("host getter")
        return self._host

    @host.setter
    def host(self, h):
        print("host setter")
        self._host = h

    @property
    def prt(self):
        print("port getter")
        return self._port

    @prt.setter
    def prt(self, p):
        print("port setter")
        self._port = p


# Precondition : Take in a string of directory to change to.
# Postcondition: The current execution enviornment will be moved to that directory and restrict it to and all sub-folders.
#                Returns the full pathname on sucess. On failure does not change and returns current working directory.
# Description  : Change the current working directory
    def set_cwd(self, new_dir):
        try:
            __cwd = './' + self._ASSET_DIRECTORY
            print('Changing the current working directory to %s\n', __cwd)
            os.chdir(__cwd)
            return __cwd
        except Exception as e1:
            print("Setting the working directory failed. CWD remains the same.")
            print(e1)
            __cwd = os.getcwd()
            return __cwd

# Precondition : Accepts a string if provided. Should only be called from a child process.
# Postcondition: returns a 0 on sucess, or a 1 on error
# Description  : Provides a basic interface to control each server instance.
    def cmds(self):
        # If a string is provided use it
        # cli = cmd_input;
        # Else accept input from the shell
        __cli = input()
        if __cli == 'Exit' or __cli =='exit' or __cli =='exit()' or __cli =='stop' or __cli =='Stop' or __cli =='end' or __cli =='End' or __cli =='Quit' or __cli =='quit' or __cli=='close' or __cli=='Close' or __cli=='abort' or cli == 'Abort':
            print('\n Shutting down server')
            print("User has initiated server shutdown")
            try:
                os._exit(0)
            except Exception as e2:
                print("Error in shutdown.")
                print(e2)
                return(1)
        return 0

# Precondition : Computer needs an active network connection.
# Postcondition: Creates socket that is listening.
# Description  : Creates a socket that can be used to accept or send network data.
    def sckt(self):
        #Need to look into exception handling for threads.
        '''https://stackoverflow.com/questions/2829329/catch-a-threads-exception-in-the-caller-thread-in-python'''
        cmd_thread = threading.Thread(target=self.cmds, args = ())
        cmd_thread.start()
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.bind((self._host, self._port))
            print("socket binded to port ", self._port)
            s.listen()          #number of connections allowed can be specified after
            print("socket listening ...")
            return s
        except Exception as e3:
            print("Failed to create socket")
            print(e3)

# Precondition : Needs a socket object.
# Postcondition: Accepts and decodes incoming data. Returns that data as a string.
# Description  : Accept incoming network data.
    def acpt(self, c):
        try:
            c_socket, c_address = c.accept()
            data = c_socket.recv(1024).decode('utf-8')
            self.connection = c_socket
            return data
        except Exception as e4:
            print("Failed to accept from socket")
            print(e4)

# Precondition : Method for inherited classes. Takes in any objects needed. 
# Postcondition: Runs methods in order and passes any parameters from one to the next as needed.
# Description  : This method is used for threading. Anything with in this method will be threaded when a server is created.
    def modules_to_thread(self):
        pass

# Precondition :
# Postcondition:
# Description  :
    def thread_server(self):
        
        s = sckt()

        while True:
            t1 = threading.Thread(target=self.modules_to_thread, args=(s,),daemon=True)
            t1.start()
            t1.join()


# if __name__ == '__main__':                  #for testing purposes
#     temp = sckt_class('127.0.0.1', 8080)
#     print(temp)
#     ahost = sckt_class('127.0.0.1', 8080)
#     ahost.set_host = '123.0.0.1'
#     print(ahost.get_host)



####################################
#   FOR TESTING PURPOSES    #
# def Socket_Class():       
#     host = ""          #will be taken from the main class
#     port = 8080        #will be taken from the main class

#     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#     s.bind((host, port))
#     print("socket binded to port ", port)
#     s.listen()          #number of connections allowed can be specified after
#     print("socket listening ...")
#     # while True:
#     #c, addr = s.accept()         #will be implemented in HTTP class
#     #print("connected to ", addr)
#         # data = c.recv(1024)
#         # if not data:
#         #     print("Bye")
#         #     break

#     s.close()             #won't need it, we want it to remain open

# if __name__ == '__main__':
#     Socket_Class()
######################################