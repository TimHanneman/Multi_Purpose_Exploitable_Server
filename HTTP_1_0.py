# Implements HTTP/1.0

#start with string
# 

# Precondition : Needs a socket_class to inherit from. Takes two strings, port and ip_address
# Postcondition: It creates a HTTP server that listens and sends info out.
# Description  : Class for creating HTTP server objects.

import socket
import os
import logging
from socket_class import sckt_class
import webbrowser

logger = logging.getLogger(__name__)

# Define socket host and port
SERVER_HOST = '0.0.0.0'
SERVER_PORT = 8080
__VERSION = '1'

# Test string for request
data = '''GET /iterlyzeBG.gif HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36 Edg/88.0.705.81
Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: image
Referer: http://127.0.0.1:8080/iterlyzeStyle.css
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9'''


# ________________________


class HTTP_1_0(sckt_class):

    logger.debug('Logger started from ' + __name__)

    status_codes = {
        200: 'OK',
        404: 'Not Found',
        500: "Internal Server Error",
        501: 'Not Implemented'
    }


    def __init__(self, ip, port) :
        self.method = None
        self.uri = None
        self.http_version = "1.0"
        self.final_response = str()
        self.connection = None

        self.ip = sckt_class(self, ip)
        self.port = sckt_class(self, port)

        #set ip and port then call sckt method
        c = self.sckt()

        #accept here
        while (True):
            data = self.acpt(c)
            self.parse(data)
            self.connection.close()

    # Precondition : Takes in a http request string
    # Postcondition: Returns None if sucessful.
    # Description  : It parses a request string to determine HTTP method.
    def parse(self, data) :

        try:
            # Split string by new line
            list = data.split("\n")

            # The first element in the list is the request line
            request_line = list[0]

            # Get individual pieces of request line
            parts = request_line.split(" ")

            self.method = parts[0]

            # If the request line has more than the request method
            #   set a variable for the URI
            if len(parts) > 1 :
                self.uri = parts[1]
                

            #   set a variable for the HTTP version
            if len(parts) > 2 :
                self.http_version = parts[2]
                
        except Exception as e5:
            logger.error(f'Parsing incoming string failed: {e5}')
            #The next line after return closes the socket
            return 1

        if(self.method == 'GET') :
            self.handle_GET(self.uri)

    # Precondition : Takes in a string that contains a GET request.
    # Postcondition: Returns a None if sucessful.
    # Description  : Sends an html file. If none is found prepares an error message and sends it.
    def handle_GET(self, req) :

        try:
            filename = self.uri.strip("/")

            if os.path.exists(filename) :
                final_response = self.response_line(status_code=200)

                with open(filename, 'rb') as f:
                    resp = f.read()
                    response_body = resp.decode('utf-8')

            else :
                final_response = self.response_line(status_code=404)
                response_body = "<h1>404 Not Found</h1> <br><br> <h3> Did you mean: HTML_files/%s" % filename

            final_R = final_response + "\r\n" + response_body

        except Exception as e6:
            #If an error occurs, it will send an error message to the requesting client
            logger.error(f'Failed to find resource or format 404 error message: {e6}')
            final_response = self.response_line(status_code=500)
            response_body = "<h1>500 Internal Error</h1>"
            final_R = final_response + "\r\n" + response_body

        try:
            final_R.encode()
        except Exception as e7:
            logger.error(f'Failed to encode header & resources to send: {e7}')
            #If encode fails close socket, break loop, close thread??
            self.connection.close()
            return(1)

        try:
            self.connection.send(final_R.encode())
        except Exception as e8:
            logger.error(f'Sending resource failed: {e8}')
            self.connection.close()
            return(1)

    # Precondition : Takes in an int of the status code.
    # Postcondition: Creates the HTTP Header string for the response.
    # Description  : Creates the HTTP Header string for the response.
    def response_line(self, status_code) :
        code = self.status_codes[status_code]
        response = "HTTP/1.0 %s %s\n" % (status_code, code)

        if(status_code == 404):
            chrome_path="C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"
            webbrowser.register('chrome', None, webbrowser.BackgroundBrowser(chrome_path))
            webbrowser.get('chrome').open('127.0.0.1:8080/HTML_files/index.html')

        return response

    
#obj = HTTP_1_0(data)

