# Implements HTTP/1.0

#import socket
#import os
#import logging
import dicts
import mimetypes
import base64
#import threading
from socket_class import *
from Modules.parse import *
from Modules.handle_get import *

logger = logging.getLogger(__name__)

# Define socket host and port
SERVER_HOST = '0.0.0.0'
SERVER_PORT = 8080
__VERSION = '1'

# Test string for request
data = '''GET /iterlyzeBG.gif HTTP/1.1
Host: 127.0.0.1:8080
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36 Edg/88.0.705.81
Accept: image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: image
Referer: http://127.0.0.1:8080/iterlyzeStyle.css
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9'''


# ________________________


class HTTP_1_0(sckt_class):
    ''' Precondition : Needs a socket_class to inherit from. Takes two strings, port and ip_address
 Postcondition: It creates a HTTP server that listens and sends info out.
 Description  : Class for creating HTTP server objects.'''

    logger.debug('Logger started from ' + __name__)
        

    def __init__(self, ip, port) :
        self.method = None
        self.uri = None
        self.http_version = "1.0"
        self.final_response = str()
        self.connection = None
        self._total_connections = 0;

        #set ip and port then call sckt method
        self.host = ip
        self.prt = port
        c = self.sckt()
        self.server_loop(c)



    def server_loop(self,c):
        '''     Precondition : Socket has been created in the listen state.
     Postcondition: Accepts a connection and processes the request
     Description  : This is the main server loop that handles incoming connections.
        '''
        #accept here
        while (True):
            #If connections less than some amount accept it otherwise, accept, reject, close connection break loop
            if(self._total_connections > 50):
                break;
            data = self.acpt(c)
            self.increment_tot_connections()

            #Create a parse object.
            self.parse_obj = Parser
            #run the parse object.
            http_method, http_uri, http_version = self.parse_obj.parser1(self.parse_obj, data)
            if (http_method == 1):
                #If the return is 1, exit else Pass the results to the next module.
                self.decrement_tot_connections()
                self.connection.close()
            else:
                #If we get further in the project these if statements can become a method
                self.type_detect(http_method,http_uri,http_version)
            self.decrement_tot_connections()
            self.connection.close()

    def increment_tot_connections(self):
        'Used to keep track of threads.'
        self._total_connections = self._total_connections + 1

    def decrement_tot_connections(self):
        'Used to keep track of threads.'
        self._total_connections = self._total_connections - 1

    #This method is for bug testing purposes to be removed later.
    def unthread_start():
        #accept here
        while (True):
            #If connections less than some amount accept it otherwise, accept, reject, close connection break loop
            if(self._total_connections > 50):
                break;
            data = self.acpt(c)
            self.increment_tot_connections()
            #self.parse(data)
            #Create a parse object.
            self.parse_obj = Parser
            #run the parse object.
            http_method, http_uri, http_version = self.parse_obj.parser1(self.parse_obj, data)
            if (http_method == 1):
                #If the return is 1, exit else Pass the results to the next module.
                self.decrement_tot_connections()
                self.connection.close()
            else:
                #If we get further in the project these if statements can become a method
                self.type_detect(http_method,http_uri,http_version)
            self.decrement_tot_connections()
            self.connection.close()

    def modules_to_thread(self):
        pass

    '''
    def thread_server(self, c):
        t1 = threading.Thread(target=self.modules_to_thread, args=(,), daemon=True)
        t1.start()
    '''

    def type_detect(self, method, uri, http_version):
        '''     Precondition : Takes 3 strings method, uri, http_version
     Postcondition: Sends the request to the appropriate request handler
     Description  : This function is used to route a request to the various request types.'''

        if (method == "GET"):
            #Create handleget object
            http_handle_get = Handle_GET
            #pass into handle get the uri
            http_handle_get.handle_GET(http_handle_get,uri, self.connection)
        else:
            return 1


    def handle_GET(self, req) :
        '''     Precondition : Takes in a string that contains a GET request.
     Postcondition: Returns a None if sucessful.
     Description  : Sends an html file. If none is found prepares an error message and sends it.'''

        try:
            filename = self.uri.strip("/")
            print(filename)

            pieces = filename.split("/")
            response_body = ""

            if os.path.exists(filename) :
                final_response = self.response_line(dicts.status_codes[200])

                with open(filename, 'rb') as f:
                    resp = f.read()
                    final_response += "Content-type: "      

                    # Check if file is in img folder
                    if(len(pieces) > 2) :
                        ext = pieces[2].split(".")

                        '''# Check if file is webp
                        if(ext[1] == "webp") :
                            string = base64.b64encode(resp)
                            response_body = string.decode('utf-8')
                            length = len(string)

                            final_response += dicts.mime_types['.webp']
                            final_response += "\r\n" + "Content-length: %s" % (length)

                        # Check if file is jpg
                        elif(ext[1] == "jpg") :
                            string = base64.b64encode(resp)
                            response_body = string.decode('utf-8')
                            length = len(string)

                            final_response += dicts.mime_types['.jpg']
                            final_response += "\r\n" + "Content-length: %s" % (length)'''

                    # Otherwise, guess MIME type
                    else :
                        response_body = resp.decode('utf-8')

                        content_type = mimetypes.guess_type(filename)[0] or 'text/html'
                        final_response += content_type

            # File not found
            else :
                final_response = self.response_line(dicts.status_codes[404])
                
                filename = "HTML_files/index.html"
                with open(filename, 'rb') as f:
                    resp = f.read()
                    response_body = resp.decode('utf-8')

                    content_type = mimetypes.guess_type(filename)[0] or 'text/html'
                    final_response += "Content-type: " + content_type

            final_R = final_response + "\r\n\r\n" + response_body

        except Exception as e6:
            #If an error occurs, it will send an error message to the requesting client
            logger.error(f'Failed to find resource or format 404 error message: {e6}')
            final_response = self.response_line(dicts.status_codes[500])

            response_body = "<h1>500 Internal Error</h1>"
            final_R = final_response + "\r\n" + response_body

        try:
            final_R.encode()
        except Exception as e7:
            logger.error(f'Failed to encode header & resources to send: {e7}')
            #If encode fails close socket, break loop, close thread??
            self.connection.close()
            return(1)

        try:
            self.connection.send(final_R.encode())
        except Exception as e8:
            logger.error(f'Sending resource failed: {e8}')
            self.connection.close()
            return(1)

